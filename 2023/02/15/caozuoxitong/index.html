<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/32×32.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/16×16.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="仅供学习参考,">










<meta name="description" content="Chapter 1 操作系统概观1.批处理与多道程序设计 2.分时系统与实时系统 3.操作系统的基本类型与特征 4.并发与并行的概念 5.操作系统的层次结构与功能模块 6.程序的并发执行与顺序执行">
<meta name="keywords" content="仅供学习参考">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统复习大纲">
<meta property="og:url" content="http://yoursite.com/2023/02/15/caozuoxitong/index.html">
<meta property="og:site_name" content="技术宅拯救世界">
<meta property="og:description" content="Chapter 1 操作系统概观1.批处理与多道程序设计 2.分时系统与实时系统 3.操作系统的基本类型与特征 4.并发与并行的概念 5.操作系统的层次结构与功能模块 6.程序的并发执行与顺序执行">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/2023/02/15/caozuoxitong/jinchengdesanzhongzhuangtai.png">
<meta property="og:image" content="http://yoursite.com/2023/02/15/caozuoxitong/jinchengdewuzhongjibenzhuangtaijizhuanhuan.png">
<meta property="og:image" content="http://yoursite.com/2023/02/15/caozuoxitong/chuliqisanjidiaodumoxing.png">
<meta property="og:image" content="http://yoursite.com/2023/02/15/caozuoxitong/duojimulujiegou.png">
<meta property="og:image" content="http://yoursite.com/2023/02/15/caozuoxitong/weishitu.png">
<meta property="og:image" content="http://yoursite.com/2023/02/15/caozuoxitong/chengzulianjiefa.png">
<meta property="og:updated_time" content="2023-02-15T14:03:29.630Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="操作系统复习大纲">
<meta name="twitter:description" content="Chapter 1 操作系统概观1.批处理与多道程序设计 2.分时系统与实时系统 3.操作系统的基本类型与特征 4.并发与并行的概念 5.操作系统的层次结构与功能模块 6.程序的并发执行与顺序执行">
<meta name="twitter:image" content="http://yoursite.com/2023/02/15/caozuoxitong/jinchengdesanzhongzhuangtai.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2023/02/15/caozuoxitong/">





  <title>操作系统复习大纲 | 技术宅拯救世界</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">技术宅拯救世界</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">其实我菜得抠脚（逃</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2023/02/15/caozuoxitong/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Grilled Fish">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/1.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="技术宅拯救世界">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">操作系统复习大纲</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2023-02-15T21:46:45+08:00">
                2023-02-15
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2023/02/15/caozuoxitong/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2023/02/15/caozuoxitong/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Chapter-1-操作系统概观"><a href="#Chapter-1-操作系统概观" class="headerlink" title="Chapter 1 操作系统概观"></a>Chapter 1 操作系统概观</h2><pre><code>1.批处理与多道程序设计
2.分时系统与实时系统
3.操作系统的基本类型与特征
4.并发与并行的概念
5.操作系统的层次结构与功能模块
6.程序的并发执行与顺序执行
</code></pre><a id="more"></a>
<h3 id="批处理与多道程序设计"><a href="#批处理与多道程序设计" class="headerlink" title="批处理与多道程序设计"></a>批处理与多道程序设计</h3><h4 id="单道批处理"><a href="#单道批处理" class="headerlink" title="单道批处理"></a>单道批处理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 处理过程该系统把一批作业以脱机方式输入到磁带上，并在系统中配上监督程序，在它的控制下使这批作业能一个接一个地连续处理，在内存中始终只保持一道作业。</span><br><span class="line">2. 特征：</span><br><span class="line">	1. 自动性</span><br><span class="line">	2. 顺序性</span><br><span class="line">	3. 单道性</span><br></pre></td></tr></table></figure>
<h4 id="多道批处理"><a href="#多道批处理" class="headerlink" title="多道批处理"></a>多道批处理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. 在该系统中，用户所提交的作业都先存放在外存上并排成一个队列，称为“后备队列”；然后，由作业调度程序按一定的算法从后备队列中选择若干个作业调入内存，使它们共享CPU和系统中的各种资源。</span><br><span class="line">2. 优点：</span><br><span class="line">	1. 资源利用率高（CPU、I/O）</span><br><span class="line">	2. 系统吞吐量大（单位时间完成的总工作量）</span><br><span class="line">3. 缺点：</span><br><span class="line">	1. 平均周转时间长</span><br><span class="line">	2. 无交互能力</span><br><span class="line">4. 需要解决的问题：</span><br><span class="line">	1. 处理机管理</span><br><span class="line">	2. 内存管理</span><br><span class="line">	3. I/O设备管理</span><br><span class="line">	4. 文件管理</span><br><span class="line">	5. 作业管理</span><br></pre></td></tr></table></figure>
<h3 id="分时系统与实时系统"><a href="#分时系统与实时系统" class="headerlink" title="分时系统与实时系统"></a>分时系统与实时系统</h3><h4 id="分时OS"><a href="#分时OS" class="headerlink" title="分时OS"></a>分时OS</h4><pre><code>1. 需求：
    1. 人机交互
    2. 共享主机
    3. 便于用户上机
2. 关键问题：
    1. 及时接收
    2. 及时处理
    3. 
3. 特征：
    1. 多路性
    2. 独立性
    3. 即时性
    4. 交互性
</code></pre><h4 id="实时OS"><a href="#实时OS" class="headerlink" title="实时OS"></a>实时OS</h4><pre><code>1. 需求：
    1. 实时控制
    2. 实时信息处理
2. 分类：
    1. 任务执行时是否呈现周期性
        1. 周期性实时任务：外部设备周期性发出激励信号，计算机按照激励信号循环执行
        2. 非周期性实时任务：外部设备所发出的激励信号并无明显的周期性，但都必须联系着一个截止时间(Deadline)。它又可分为开始截止时间（某任务在某时间以前必须开始执行）和完成截止时间（某任务在某时间以前必须完成）两部分
    2. 对截止时间的要求：
        1. 硬实时：某个动作必须在规定时间完成（导弹、飞控）
        2. 软实时：可以接收偶尔违反时间规定（飞机订票系统、银行管理系统）
</code></pre><h4 id="分时OS和实时OS的比较"><a href="#分时OS和实时OS的比较" class="headerlink" title="分时OS和实时OS的比较"></a>分时OS和实时OS的比较</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 多路性：实时操作系统也要按照分时原则为多个终端服务</span><br><span class="line">2. 独立性：多个用户彼此互不干扰</span><br><span class="line">3. 及时性：实时OS要求更高</span><br><span class="line">4. 交互性：实时信息处理系统虽然也具有交互性，但这里人与系统的交互仅限于访问系统中某些特定的专用服务程序</span><br><span class="line">5. 可靠性：实时OS要求更高</span><br></pre></td></tr></table></figure>
<h3 id="操作系统的类型和基本特征"><a href="#操作系统的类型和基本特征" class="headerlink" title="操作系统的类型和基本特征"></a>操作系统的类型和基本特征</h3><p>操作系统的基本类型：</p>
<table>
<thead>
<tr>
<th></th>
<th>单道批处理</th>
<th>多道批处理</th>
<th>分时</th>
<th>实时（硬实时/软实时）</th>
<th>网络（客户/服务机）</th>
<th>分布式</th>
<th>个人操作系统</th>
</tr>
</thead>
<tbody>
<tr>
<td>特征</td>
<td>自动性、顺序性、单道性</td>
<td>多道、宏观上并行、微观上串行</td>
<td>同时性、独立性、及时性、交互性</td>
<td>及时性、可靠性</td>
<td>共享</td>
<td>分布性、并行性</td>
<td>windows、Linux、macOS</td>
</tr>
<tr>
<td>优点</td>
<td></td>
<td>资源利用率高、系统吞吐量大</td>
<td>人机交互能力</td>
<td></td>
<td></td>
<td>系统内的若干计算机完成同一任务</td>
<td></td>
</tr>
<tr>
<td>缺点</td>
<td>资源利用率与系统吞吐量较低</td>
<td>用户响应时间长、没有人机交互能力</td>
<td>不能对外部信息在规定时间内做出处理</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>**分时操作系统与批处理系统的不同点：追求目标不同、适应作业不同、资源利用率不同、作业控制方式不同。</p>
<p>操作系统的基本特征：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 并发性（最重要）：指两个或两个以上的活动或事件在同一个时间间隔内发生。并发性会使操作系统的设计和实现变得复杂化。</span><br><span class="line"></span><br><span class="line">2. 共享性：指计算机系统的资源可以被多个并发执行的程序共同使用，而不是被某个程序独占。与共享性有关的问题是资源分配、信息保护、存取控制。</span><br><span class="line">	1. 互斥共享：打印机、磁带机</span><br><span class="line">	2. 同时访问：宏观同时，微观交替访问，例如磁盘</span><br><span class="line">3. 虚拟性</span><br><span class="line">	1. 时分复用</span><br><span class="line">	2. 空分复用：虚拟磁盘、虚拟存储器</span><br><span class="line">4. 异步性：在多道程序环境中，允许多个程序并发执行，并发活动会导致随机事件的发生。异步性会给系统带来潜在的危险，有可能会导致并发程序的执行产生与时间有关的错误。</span><br></pre></td></tr></table></figure>
<h4 id="操作系统的目标和功能"><a href="#操作系统的目标和功能" class="headerlink" title="操作系统的目标和功能"></a>操作系统的目标和功能</h4><ol>
<li><p>操作系统作为资源的管理者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 处理机管理（进程控制、进程同步、进程通信、死锁处理、处理机调度）</span><br><span class="line">2. 存储器管理（内存分配/回收、地址映射、内存保护/共享、内存扩充）</span><br><span class="line">3. 文件管理（存储空间管理、目录管理、读写管理/保护）</span><br><span class="line">4. 设备管理（缓冲管理、设备分配、设备处理、虚拟设备）</span><br></pre></td></tr></table></figure>
</li>
<li><p>操作系统作为用户与硬件系统之间的接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. 命令接口</span><br><span class="line">    联机控制方式（交互式命令接口）</span><br><span class="line">    脱机控制方式（批处理命令接口）：.bat</span><br><span class="line"></span><br><span class="line">2. 程序接口</span><br><span class="line">    程序接口由一组系统调用（广义指令）组成。</span><br><span class="line"></span><br><span class="line">3. 操作系统实现了对计算机资源的扩充</span><br><span class="line">    裸机：没有软件支持的计算机</span><br><span class="line">    虚拟机：覆盖了软件的机器</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="并发与并行的概念"><a href="#并发与并行的概念" class="headerlink" title="并发与并行的概念"></a>并发与并行的概念</h3><h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 多个进程在同一段时间内运行。</span><br><span class="line">2. OS的并发性是指计算机OS中同时存在多个运行的程序，具备处理和调度多个程序同时执行的能力</span><br></pre></td></tr></table></figure>
<h4 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 并行性是指OS具有同时进行运算或操作的特性，在同一时刻能完成两种或两种以上的工作</span><br><span class="line">2. 并行性需要硬件的支持，如多流水线或多处理机</span><br></pre></td></tr></table></figure>
<h3 id="计算机层次结构与功能模块"><a href="#计算机层次结构与功能模块" class="headerlink" title="计算机层次结构与功能模块"></a>计算机层次结构与功能模块</h3>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">组成：硬件和软件。</span><br><span class="line">层次结构：应用程序-&gt;系统程序-&gt;操作系统-&gt;硬件。</span><br><span class="line">功能模块：</span><br></pre></td></tr></table></figure>
<ol>
<li><p>分层</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">优点：</span><br><span class="line">	1. 便于系统调试和验证</span><br><span class="line">	2. 易扩充、易维护</span><br><span class="line">缺点：</span><br><span class="line">	1. 合理定义各层较难</span><br><span class="line">	2. 效率较差：完成一个功能都需要穿越多层，每层之间的通讯机制增加了开销（0-copy）</span><br></pre></td></tr></table></figure>
</li>
<li><p>模块化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. 衡量独立性的标准：</span><br><span class="line">	1. 内聚性：模块内部各部分间联系的紧密程度</span><br><span class="line">	2. 耦合性：模块间相互联系和影响的程度</span><br><span class="line">2. 优点：</span><br><span class="line">	1. 提高设计的正确性、可理解性、和可维护性</span><br><span class="line">	2. 增强OS的可适应性</span><br><span class="line">	3. 加速OS的开发过程</span><br><span class="line">3. 缺点：</span><br><span class="line">	1. 模块间的接口设计很难匹配实际需求</span><br><span class="line">	2. 无法找到可靠的决定顺序</span><br></pre></td></tr></table></figure>
</li>
<li><p>宏内核</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">优点：高效</span><br><span class="line">缺点：随OS设计规模的发展越来越复杂</span><br><span class="line">目前主流是以宏内核为基础，吸收微内核优点的混合内核架构</span><br></pre></td></tr></table></figure>
</li>
<li><p>微内核</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1. 微内核将内核中最基本的功能保留在内核，将不需要在核心态运行的功能移动到用户态执行</span><br><span class="line">2. 微内核将OS分为两个部分：</span><br><span class="line">	1. 微内核：</span><br><span class="line">		1. 与硬件处理联系紧密的部分</span><br><span class="line">		2. 一些基本的功能</span><br><span class="line">		3. 客户和服务机之间的通信</span><br><span class="line">	2. 多个服务器</span><br><span class="line">3. 微内核结构通常利用“机制和策略分离”的原理构造OS结构：</span><br><span class="line"> 	1. 进程管理：</span><br><span class="line"> 		1. 内核中实现进程的切换、调度、多处理机简单同步等机制</span><br><span class="line"> 		2. 服务器中实现进程的分类、优先级的确认等策略</span><br><span class="line"> 	2. 低级存储器管理：</span><br><span class="line"> 		1. 内核中实现逻辑地址与物理地址间的变换、页表、地址变换等机制</span><br><span class="line"> 		2. 服务器中实现页面置换算法、内存分配及回收等策略</span><br><span class="line"> 	3. 中断和陷入处理：</span><br><span class="line"> 		1. 内核中只保留与硬件紧密相关的一部分，主要工作是捕获所发生的中断和陷入事件并发送给相应的服务器处理</span><br><span class="line"> 		2. 服务器提供中断服务程序，因中断的事件不同而有不同的处理</span><br><span class="line">3. 优点：</span><br><span class="line">	1. 扩展性和灵活性</span><br><span class="line">	2. 可靠性和安全性</span><br><span class="line">	3. 可移植性</span><br><span class="line">	4. 分布式计算</span><br><span class="line">4. 缺点：</span><br><span class="line">	1. 小内核导致CPU在内核态和用户态之间频繁切换，增大开销</span><br><span class="line">	2. 提高执行效率的同时会导致内核增大，需要平衡二号取舍</span><br><span class="line">5. 微内核在实时、工业、航空及军事应用中特别流行</span><br></pre></td></tr></table></figure>
</li>
<li><p>外核</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 虚拟机除了克隆真实机器，另一种策略是对机器进行分区，给每个用户整个资源的一个子集</span><br><span class="line">2. 外核（进程）运行在内核态，用于为虚拟机分配资源，并检查资源请求是否合法，确保每台虚拟机都只使用自己的资源</span><br><span class="line">3. 优点：</span><br><span class="line">	1. 减少了映射层：如果每台虚拟机认为自己拥有整个资源，虚拟机监控程序就需要为每台虚拟机维护一张资源映射表</span><br><span class="line">	2. 减少负载：外核将多道程序（在外核内）与用户操作系统代码（在用户空间中）加以分离，减轻负载</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="程序的顺序执行与并发执行"><a href="#程序的顺序执行与并发执行" class="headerlink" title="程序的顺序执行与并发执行"></a>程序的顺序执行与并发执行</h3><p>顺序执行：单处理机、没有操作系统</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 顺序性</span><br><span class="line">2. 封闭性：程序运行时独占全机资源</span><br><span class="line">3. 可再现性</span><br></pre></td></tr></table></figure>
<p>并发执行：与异步执行的定义不同</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 间断性：多道程序环境允许多个程序并发运行，但程序的执行不是一贯到底的，而是走走停停，以未知的速度推进</span><br><span class="line">2. 失去封闭性：多个程序共享的资源被运行中的程序更改，程序之间相互影响</span><br><span class="line">3. 不可再现性（异步性保证能再现）：失去封闭性导致失去可再现性</span><br></pre></td></tr></table></figure>
<h2 id="Chapter-2-进程管理"><a href="#Chapter-2-进程管理" class="headerlink" title="Chapter 2 进程管理"></a>Chapter 2 进程管理</h2><pre><code>1. 进程:进程控制块、进程的几种基本状态与状态转换（进程的创建、进程的终止、进程的阻塞与唤醒、进程的挂起与激活等)
2. 进程的同步与互斥:临界资源、临界区、进程同步与互斥问题、信号量机制以及P、V操作、管程机制
3. 进程间通信:进程通信的类型(直接通信和间接通信方式)、消息传递系统中的几个问题、消息缓冲队列通信机制
4. 线程与进程的调度:线程与进程的基本概念，调度的类型、调度队列模型、调度方式、进程调度算法（先来先服务、短进程优先、时间片轮转、基于优先级的调度算法等)
5. 死锁:死锁的基本概念，死锁定理、死锁预防、死锁避免与处理死锁的基本方法、银行家算法
6. 综合应用:生产者消费者问题、读者和写者问题、哲学家进餐问题等
</code></pre><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">进程 = 程序段 + 数据段 + PCB</span><br></pre></td></tr></table></figure>
<h4 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 进程描述信息</span><br><span class="line">2. 进程控制和管理信息</span><br><span class="line">3. 资源分配清单</span><br><span class="line">4. 处理机相关信息（上下文）</span><br></pre></td></tr></table></figure>
<h4 id="进程的几种基本状态与状态转换"><a href="#进程的几种基本状态与状态转换" class="headerlink" title="进程的几种基本状态与状态转换"></a>进程的几种基本状态与状态转换</h4><p>进程申请了PCB但资源（如内存）不足时，并不是创建失败，而是处于创建态，等待资源分配。</p>
<p><img src="/2023/02/15/caozuoxitong/jinchengdesanzhongzhuangtai.png" alt></p>
<p><img src="/2023/02/15/caozuoxitong/jinchengdewuzhongjibenzhuangtaijizhuanhuan.png" alt></p>
<h3 id="进程的同步与互斥"><a href="#进程的同步与互斥" class="headerlink" title="进程的同步与互斥"></a>进程的同步与互斥</h3><h4 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 临界资源是同一时刻只允许一个进程访问的资源</span><br><span class="line">2. 没有临界资源机制导致程序失去再现性</span><br></pre></td></tr></table></figure>
<h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 临界区：进程中访问临界资源的代码段</span><br><span class="line">2. 进程互斥的访问临界区 = 互斥访问临界资源</span><br></pre></td></tr></table></figure>
<h4 id="进程同步与互斥问题"><a href="#进程同步与互斥问题" class="headerlink" title="进程同步与互斥问题"></a>进程同步与互斥问题</h4><p>实现互斥的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 信号量 软硬都有（关中断/原子操作）</span><br><span class="line">2. 硬件实现 tsl</span><br><span class="line">3. 软件实现：</span><br><span class="line">	1. 单标志 turn</span><br><span class="line">	2. 双标志先检查法：必须交替进行</span><br><span class="line">	4. 双标志后检查法：可能相互谦让导致饥饿</span><br><span class="line">	5. 皮特森</span><br><span class="line">4. 管程</span><br></pre></td></tr></table></figure>
<p>经典同步问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 生产者、消费者</span><br><span class="line">2. 哲学家进餐</span><br><span class="line">3. 读者、写者问题</span><br></pre></td></tr></table></figure>
<h4 id="信号量机制以及P、V操作"><a href="#信号量机制以及P、V操作" class="headerlink" title="信号量机制以及P、V操作"></a>信号量机制以及P、V操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">信号量分为整型信号量与记录型信号量。</span><br><span class="line">记录型信号量可以解决忙等问题。</span><br></pre></td></tr></table></figure>
<h4 id="管程机制-monitor"><a href="#管程机制-monitor" class="headerlink" title="管程机制(monitor)"></a>管程机制(monitor)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">只允许被一个进程调用的类</span><br><span class="line">1. 管程的名称</span><br><span class="line">2. 定义管程内部的共享数据结构（共享数据结构 = 可共享资源）</span><br><span class="line">3. 对管程的操作</span><br><span class="line">4. 对管程的初始化</span><br></pre></td></tr></table></figure>
<p>条件变量(condition)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">condition x;//声明一个条件变量x</span><br><span class="line">x.value = 1;//初始化x</span><br><span class="line">x.wait();//排队</span><br><span class="line">x.signal();//唤醒一个阻塞进程</span><br><span class="line"></span><br><span class="line">条件变量是没有值的，条件变量是一个数据结构，与信号量相比只是实现了“排队等待”功能。</span><br></pre></td></tr></table></figure>
<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>低级通信：PV操作（信号量），信号</p>
<p>高级通信：高速率、多数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 共享存储</span><br><span class="line">	低级：基于数据结构</span><br><span class="line">	高级：基于存储区</span><br><span class="line">2. 消息传递</span><br><span class="line">	直接通信方式</span><br><span class="line">	间接通信方式</span><br><span class="line">3. 管道通信</span><br><span class="line">	以特殊文件的形式存在（通过FCB操作缓冲区）</span><br><span class="line">	实际是一个固定大小缓冲区</span><br></pre></td></tr></table></figure>
<h4 id="进程通信的类型-直接通信和间接通信方式"><a href="#进程通信的类型-直接通信和间接通信方式" class="headerlink" title="进程通信的类型(直接通信和间接通信方式)"></a>进程通信的类型(直接通信和间接通信方式)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">直接通信：发送进程将消息挂在目标进程的消息缓冲队列上</span><br><span class="line">间接通信：通信双方通过信箱（共享数据结构的实体）交换信息，广泛应用与计算机网络中</span><br></pre></td></tr></table></figure>
<h4 id="消息传递系统中的几个问题"><a href="#消息传递系统中的几个问题" class="headerlink" title="消息传递系统中的几个问题"></a>消息传递系统中的几个问题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1. 通信链路：</span><br><span class="line">	1. 点对点、多点连接</span><br><span class="line">	2. 无容量、有容量通信链路、</span><br><span class="line">2. 消息的格式</span><br><span class="line">3. 进程同步方式：</span><br><span class="line">	1. 发送进程阻塞，接收进程阻塞：</span><br><span class="line">		1. 用于进程之间紧密同步，且无缓冲</span><br><span class="line">		2. 两个进程都处于阻塞状态，直到有消息传递</span><br><span class="line">	2. 发送进程不阻塞，接收进程阻塞：</span><br><span class="line">		1. 用于尽快将一个或多个消息发送给多个目标，应用广泛</span><br><span class="line">		2. 接收进程平时处于阻塞状态，知道接收到消息才被唤醒，例如打印服务</span><br><span class="line">	3. 发送、接收进程均不阻塞：</span><br><span class="line">		1. 发送、接收进程无法继续运行时才阻塞</span><br><span class="line">		2. 例如无法向消息队列发送信息（已满），或者无法从消息队列（已空）取得信息时</span><br><span class="line">		3. 类似生产者消费者模型？</span><br></pre></td></tr></table></figure>
<h4 id="消息缓冲队列通信机制"><a href="#消息缓冲队列通信机制" class="headerlink" title="消息缓冲队列通信机制"></a>消息缓冲队列通信机制</h4><p>在这种通信机制中， 发送进程利用send源语将消息直接发给接收进程，接收进程利用receive源语接收消息。<strong>使用了信号量互斥机制</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. 消息缓冲队列通信机制中的数据结构</span><br><span class="line">	1. 消息缓冲区</span><br><span class="line">		1. 发送者进程标识符</span><br><span class="line">		2. 消息长度</span><br><span class="line">		3. 消息正文</span><br><span class="line">		4. 指向下一个消息缓冲区的指针</span><br><span class="line">	2. PCB中有关通信的数据项</span><br><span class="line">		1. 消息队列首指针</span><br><span class="line">		2. 消息队列互斥信号量</span><br><span class="line">		3. 消息队列资源信号量</span><br><span class="line">2. 发送源语</span><br><span class="line">3. 接收源语</span><br></pre></td></tr></table></figure>
<h3 id="线程与进程的调度"><a href="#线程与进程的调度" class="headerlink" title="线程与进程的调度"></a>线程与进程的调度</h3><h4 id="线程与进程的基本概念"><a href="#线程与进程的基本概念" class="headerlink" title="线程与进程的基本概念"></a>线程与进程的基本概念</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">进程是资源分配的基本单位</span><br><span class="line">线程是独立调度的基本单位，线程切换的代价远小于进程切换</span><br><span class="line">线程不拥有系统资源（仅有一点保证独立运行的资源）</span><br><span class="line">不同线程可以执行相同的程序，当一个程序被不同用户调用时，OS将其创建成不同的线程</span><br><span class="line">线程没有创建态</span><br></pre></td></tr></table></figure>
<p>多线程模型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 多对一（一旦一个用户线程被阻塞，其他线程也动不了。因为只有一个核心线程）</span><br><span class="line">2. 一对一</span><br><span class="line">3. 多对多（核心线程少于用户线程）</span><br></pre></td></tr></table></figure>
<h4 id="调度的类型"><a href="#调度的类型" class="headerlink" title="调度的类型"></a>调度的类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 高级调度（作业调度）：外存-&gt;创建态-&gt;就绪态 内存与外存之间的调度</span><br><span class="line">2. 中级调度（内存调度）：运行态&lt;-&gt;挂起态（调入外存） 提高内存利用率和系统吞吐量</span><br><span class="line">3. 低级调度（进程调度）：就绪态-&gt;运行态</span><br></pre></td></tr></table></figure>
<h4 id="调度队列模型"><a href="#调度队列模型" class="headerlink" title="调度队列模型"></a>调度队列模型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 作业调度为进程活动做准备，进程调度使进程正常活动起来</span><br><span class="line">2. 中级调度将暂时不能运行的进程挂起</span><br><span class="line">3. 作业调度次数最少，中级调度次数略多，进程调度最频繁</span><br><span class="line">4. 进程调度（低级调度）是最基本的，不能或缺</span><br></pre></td></tr></table></figure>
<p><img src="/2023/02/15/caozuoxitong/chuliqisanjidiaodumoxing.png" alt></p>
<h4 id="调度方式"><a href="#调度方式" class="headerlink" title="调度方式"></a>调度方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">剥夺式调度（抢占式）：当进程正在处理器上运行时，系统可根据所规定的原则剥夺分配给此进程的处理器，并将其移入就绪队列，选择其他进程运行。</span><br><span class="line"></span><br><span class="line">非剥夺式调度（非抢占式）：一旦某个进程开始运行后便不再让出处理器，除非此进程运行结束，或主动放弃处理器，或因发生某个事件而不能继续执行。</span><br></pre></td></tr></table></figure>
<h4 id="调度的目标"><a href="#调度的目标" class="headerlink" title="调度的目标"></a>调度的目标</h4><p>$$<br>CPU利用率 = \frac{CPU有效工作时间}{CPU有效工作时间 + CPU空闲等待时间}<br>$$</p>
<p>$$<br>周转时间 = 作业完成时间 - 作业提交时间<br>$$</p>
<p>$$<br>带权周转时间 = \frac{作业周转时间}{作业实际运转时间}<br>$$</p>
<p>$$<br>等待时间 = \sum_0^{\infty}{进程处于等待处理机的时间}<br>$$</p>
<p>$$<br>相应比R_p = \frac{等待时间 + 要求服务时间}{要求服务时间}<br>$$</p>
<h4 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 先来先服务</span><br><span class="line">2. 短进程优先</span><br><span class="line">3. 时间片轮转</span><br><span class="line">4. 基于优先级的调度算法</span><br><span class="line">5. 多级队列</span><br><span class="line">6. 多级反馈队列</span><br></pre></td></tr></table></figure>
<p>多级反馈队列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 设置多个就绪队列</span><br><span class="line">2. 时间片随队列优先级增高而减小</span><br><span class="line">3. 每个队列都采用FCFS</span><br><span class="line">4. 按队列优先级调度，优先级高的队列为空时才调度低一级队列。新进入高优先级进程后，立即把处理机分配给高优先队列。</span><br></pre></td></tr></table></figure>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="死锁的基本概念"><a href="#死锁的基本概念" class="headerlink" title="死锁的基本概念"></a>死锁的基本概念</h4><ol>
<li><p>系统资源的竞争</p>
</li>
<li><p>进程推进顺序非法</p>
</li>
<li><p>死锁产生的必要条件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 互斥条件：系统中存在临界资源，进程应互斥地使用这些资源</span><br><span class="line"></span><br><span class="line">2. 占有和等待条件：进程在请求资源得不到满足而等待时，不释放已占有资源</span><br><span class="line"></span><br><span class="line">3. 不剥夺条件：已被占用的资源只能由属主释放，不允许被其他进程剥夺</span><br><span class="line"></span><br><span class="line">4. 循环等待条件：存在循环等待链，其中，每个进程都在链中等待下一个进程所持有的资源，造成这组进程处于永远等待状态</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h4><p>破坏死锁产生的必要条件之一。</p>
<h4 id="死锁避免与处理死锁的基本方法"><a href="#死锁避免与处理死锁的基本方法" class="headerlink" title="死锁避免与处理死锁的基本方法"></a>死锁避免与处理死锁的基本方法</h4><p>银行家算法</p>
<h4 id="死锁定理（死锁检测）"><a href="#死锁定理（死锁检测）" class="headerlink" title="死锁定理（死锁检测）"></a>死锁定理（死锁检测）</h4><p>如果能消去资源分配图中所有的边，那么此图是可完全简化的。</p>
<p>S为死锁的条件是，当且仅当S状态的资源分配图是不可完全简化的。</p>
<p>原理和银行家算法差不多，只不过死锁检测发生在进程运行时，而死锁避免发生在进程运行前。</p>
<h2 id="Chapter-3-内存管理"><a href="#Chapter-3-内存管理" class="headerlink" title="Chapter 3 内存管理"></a><strong>Chapter 3 内存管理</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 内存管理的需求：重定位、内存保护、内存共享</span><br><span class="line">2. 程序的装入和链接：静态装入和可重定位装入、静态链接、动态链接、运行时动态链接</span><br><span class="line">3. 分区存储管理：分区方式（单一连续分区、固定分区、可变式分区）、分区分配算法（首次适应算法、循环首次适应算法、最佳适应法、最坏适应法等）</span><br><span class="line">4. 段式管理与页式管理：段、页、碎片等基本概念、段式管理与页式管理机制</span><br><span class="line">5. 虚拟内存：局部性原理、虚拟内存概念、请求分段与请求分页、段页式管理、段页式地址结构与地址转换、页面置换算法（OPT、先进先出、LRU、Clock、改进型 Clock 置换）、抖动</span><br></pre></td></tr></table></figure>
<h3 id="内存管理的需求"><a href="#内存管理的需求" class="headerlink" title="内存管理的需求"></a>内存管理的需求</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">重定位：程序-&gt;进程，逻辑地址-&gt;物理地址</span><br><span class="line">内存保护：各道作业在各自的存储空间内运行，互不干扰</span><br><span class="line">内存共享：允许多个进程访问内存的同一部分</span><br></pre></td></tr></table></figure>
<h3 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h3><p>链接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. 静态链接</span><br><span class="line">	1. 所有目标模块都使用同一套逻辑地址</span><br><span class="line">	2. 外部调用符号也变换为逻辑地址：函数名换成逻辑地址</span><br><span class="line">2. 装入时动态链接</span><br><span class="line">	1. 边装入边链接</span><br><span class="line">	2. 便于修改和更新</span><br><span class="line">	3. 此方法是在装入时把每个目标及对应外部调用模块链接在一起装入内存，而实际上程序执行过程中，一些外部调用模块可能是用不上的</span><br><span class="line">3. 运行时动态链接</span><br><span class="line">	1. 目标模块需要时再调入内存和被链接到装入模块上</span><br><span class="line">	2. 加快程序装入过程，节省大量内存空间</span><br></pre></td></tr></table></figure>
<p>装入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. 绝对装入</span><br><span class="line">	1. 单道程序系统</span><br><span class="line">	2. 事先知道程序将驻留在内存中的位置，用户编译程序后，产生绝对地址（与实际物理地址相同）的目标代码</span><br><span class="line">2. 可重定位装入</span><br><span class="line">	1. 多道程序系统</span><br><span class="line">	2. 地址变换在装入时一次完成</span><br><span class="line">	3. 分配要求的所有空间，运行期间不能移动</span><br><span class="line">3. 动态运行时装入</span><br><span class="line">	1. 地址变换在程序执行时进行</span><br><span class="line">	2. 可以将程序分配到不连续的存储区</span><br></pre></td></tr></table></figure>
<h3 id="连续分配：分区存储管理"><a href="#连续分配：分区存储管理" class="headerlink" title="连续分配：分区存储管理"></a>连续分配：分区存储管理</h3><h4 id="分区方式"><a href="#分区方式" class="headerlink" title="分区方式"></a>分区方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 单一连续分区</span><br><span class="line">2. 固定分区 -&gt; 内部碎片</span><br><span class="line">3. 可变式分区 -&gt; 外部碎片</span><br></pre></td></tr></table></figure>
<h4 id="可变式分区：分区分配算法"><a href="#可变式分区：分区分配算法" class="headerlink" title="可变式分区：分区分配算法"></a>可变式分区：分区分配算法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 首次适应算法：从空闲链首开始，找到大小能满足要求的第一个空闲分区</span><br><span class="line">2. 循环首次适应法（邻近适应）：从上次查找结束的位置开始继续查找，找到大小能满足要求的第一个空闲分区</span><br><span class="line">3. 最佳适应法：空闲区递增链接，找到最小能满足的空闲分区（最多外部碎片）</span><br><span class="line">4. 最坏适应法等：空闲区递减链接，找到最大能满足的空闲分区</span><br></pre></td></tr></table></figure>
<p>回收内存时：相邻空闲分区将合并成一个大空闲分区</p>
<h4 id="伙伴系统：固定分区和动态分区的折中"><a href="#伙伴系统：固定分区和动态分区的折中" class="headerlink" title="伙伴系统：固定分区和动态分区的折中"></a>伙伴系统：固定分区和动态分区的折中</h4><p>伙伴系统规定，无论已分配分区或空闲分区，其大小均为$$2^k，k\geq1$$。</p>
<p>合并时若当前空闲分区大小为$$2^i$$，则应将与伙伴分区合并为大小为$$2^{i+1}$$的分区。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 性能取决于查找空闲分区的位置和分割、合并空闲分区所花的时间：</span><br><span class="line">	1. 顺序搜索算法 &lt; 时间性能 &lt; 分类搜索算法</span><br><span class="line">	2. 分类搜索算法 &lt;&lt; 空间性能 &lt; 顺序算法</span><br><span class="line">2. 分页、分段性能优于伙伴系统，但伙伴系统在多处理机系统中作为亿中有效的内存分配和释放的方法，仍有大量应用</span><br></pre></td></tr></table></figure>
<h3 id="离散分配：基本段式管理与页式管理"><a href="#离散分配：基本段式管理与页式管理" class="headerlink" title="离散分配：基本段式管理与页式管理"></a>离散分配：基本段式管理与页式管理</h3><h4 id="快表TLB"><a href="#快表TLB" class="headerlink" title="快表TLB"></a>快表TLB</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 基于局部性原理</span><br><span class="line">2. 主存中的称为慢表</span><br><span class="line">3. 快表中存储页表项</span><br><span class="line">4. 慢表中的查询结果应该存入快表，若快表已满，则按照特定算法淘汰</span><br></pre></td></tr></table></figure>
<h4 id="页式管理机制"><a href="#页式管理机制" class="headerlink" title="页式管理机制"></a>页式管理机制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 提高内存利用率，不会产生外部碎片</span><br><span class="line">2. 由硬件机制负责，对用户透明</span><br><span class="line">3. OS为进程建立页表，页表是由页表项组成</span><br><span class="line">4. 为了压缩页表，可以建立多级页表</span><br></pre></td></tr></table></figure>
<p>地址结构：</p>
<table>
<thead>
<tr>
<th style="text-align:center">页号</th>
<th style="text-align:center">页内偏移</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>多级页表地址结构：</p>
<table>
<thead>
<tr>
<th style="text-align:center">一级页号</th>
<th style="text-align:center">二级页号</th>
<th style="text-align:center">页内偏移</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>页表项结构：</p>
<table>
<thead>
<tr>
<th style="text-align:center">页号</th>
<th style="text-align:center">块号</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>物理地址RA ：</p>
<table>
<thead>
<tr>
<th style="text-align:center">块号</th>
<th style="text-align:center">页内偏移</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h4 id="段式管理"><a href="#段式管理" class="headerlink" title="段式管理"></a>段式管理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 按照用户进程中的自然段划分逻辑空间（程序段、栈段、数据段...）</span><br><span class="line">2. 段式系统的段号、段内偏移必须由用户显式提供。高级语言中由编译器负责。</span><br><span class="line">3. 段式系统方便共享</span><br><span class="line">	1. 可共享段：纯代码（可重入代码），不可修改，不属于临界区</span><br><span class="line">	2. 不可共享段：可修改的代码</span><br><span class="line">4. 段式系统方便保护</span><br><span class="line">	1. 存取控制保护</span><br><span class="line">	2. 地址越界保护（产生越界中断）</span><br></pre></td></tr></table></figure>
<p>逻辑地址：</p>
<table>
<thead>
<tr>
<th style="text-align:center">段号</th>
<th style="text-align:center">段内偏移</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>段表项结构：</p>
<table>
<thead>
<tr>
<th style="text-align:center">段号</th>
<th style="text-align:center">段长</th>
<th style="text-align:center">段首地址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h3 id="虚拟内存："><a href="#虚拟内存：" class="headerlink" title="虚拟内存："></a>虚拟内存：</h3><h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><p>高速缓存能够提高OS性能的原理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 时间局部性：当某个数据被访问，不久后这个数据又将被访问（产生原因：循环操作）</span><br><span class="line">2. 空间局部性：当某块存储单元被访问，不久后这块存储单元又将被访问（产生原因：指令顺序存放、顺序执行、数据簇聚存储）</span><br></pre></td></tr></table></figure>
<h4 id="虚拟内存概念"><a href="#虚拟内存概念" class="headerlink" title="虚拟内存概念"></a>虚拟内存概念</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 请求分页存储管理</span><br><span class="line">2. 请求分段存储管理</span><br><span class="line">3. 请求段页式存储管理</span><br></pre></td></tr></table></figure>
<p>内存分配策略</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 固定分配局部置换：分配的物理块不变</span><br><span class="line">2. 可变分配全局置换：发生缺页 -&gt; 增加物理块 -&gt; 调入页面</span><br><span class="line">3. 可变分配局部置换：</span><br><span class="line">	1. 发生缺页 -&gt; 选一页置换</span><br><span class="line">	2. 频繁发生缺页 -&gt; 增加物理块 -&gt; 调入页面</span><br></pre></td></tr></table></figure>
<p>调入页面时机：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 预调页策略</span><br><span class="line">	1. 用于进程的首次调入</span><br><span class="line">	2. 由程序员指出先调入哪些页</span><br><span class="line">2. 请求调页策略</span><br><span class="line">	1. 运行期间调入</span><br></pre></td></tr></table></figure>
<p>从何处调入页面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">请求分页系统中的外存分为两部分：</span><br><span class="line">	1. 文件区：离散分配</span><br><span class="line">	2. 对换区：连续分配</span><br><span class="line">当发生缺页请求时，系统调入内存分为三种情况：</span><br><span class="line">	1. 对换区空间足够：运行前将文件从文件区复制到对换区</span><br><span class="line">	2. 对换区空间不足：文件中可能被修改的部分从文件区复制到对换区，不被修改的直接从文件区读取</span><br><span class="line">	3. UNIX方式：未运行过的页面从文件区调入，运行过被换出的放在对换区</span><br></pre></td></tr></table></figure>
<p><strong>虚拟内存的特征：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 多次性：一个作业被分成多次调入内存</span><br><span class="line">2. 对换性：再作业运行的过程中允许换出</span><br><span class="line">3. 虚拟性：能从逻辑上扩充内存容量</span><br></pre></td></tr></table></figure>
<h4 id="请求分段与请求分页"><a href="#请求分段与请求分页" class="headerlink" title="请求分段与请求分页"></a>请求分段与请求分页</h4><p><strong>请求分段</strong></p>
<p>在分段系统的基础上，增加了<strong>请求调段</strong>及<strong>分段置换</strong>功能后所形成的段式虚拟存储系统。允许只装入少数段的用户程序和数据，即可启动运行。在运行过程中，再通过请求调段及分段置换将暂不运行的段调出，并调入即将运行的段。置换是以段为单位进行的。</p>
<p>请求分段需要硬件支持：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 请求分段的段表机制</span><br><span class="line">2. 缺段中断机构</span><br><span class="line">3. 地址变换机构</span><br></pre></td></tr></table></figure>
<h5 id="请求分页"><a href="#请求分页" class="headerlink" title="请求分页"></a>请求分页</h5><p>页表项：</p>
<table>
<thead>
<tr>
<th style="text-align:center">页号</th>
<th style="text-align:center">物理块号</th>
<th style="text-align:center">状态位</th>
<th style="text-align:center">访问字段</th>
<th style="text-align:center">修改位</th>
<th style="text-align:center">外存地址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h4 id="段页式管理"><a href="#段页式管理" class="headerlink" title="段页式管理"></a>段页式管理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 提高内存利用率，反应程序逻辑结构，便于共享和保护</span><br><span class="line">2. OS为每个进程建立一张段表，每个分段有一张页表（一张段表，多张页表）</span><br><span class="line">3. 有段表寄存器记录作业的段首地址和段表长度（作用是寻址和防止越界）</span><br></pre></td></tr></table></figure>
<p>逻辑地址：</p>
<table>
<thead>
<tr>
<th style="text-align:center">段号</th>
<th style="text-align:center">页号</th>
<th style="text-align:center">页内偏移</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>段表项：</p>
<table>
<thead>
<tr>
<th style="text-align:center">段号</th>
<th style="text-align:center">段长</th>
<th style="text-align:center">页表首地址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><p>FIFO可能出现belady异常，LRU和OPT不会出现belady</p>
<p>belady：页面异常次数随分配物理块数增加而增加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. OPT：向后看</span><br><span class="line">2. FIFO先进先出</span><br><span class="line">3. LRU：向前看</span><br><span class="line">4. Clock（最近未使用）：</span><br><span class="line">	1. 只有一位访问位</span><br><span class="line">	2. 向下找第一个访问位为0的页面换出</span><br><span class="line">	3. 边找边将访问位为1的置0</span><br><span class="line">5. 改进型 Clock 置换）：相比于CLock可以减少IO次数</span><br><span class="line">	1. 找A=0, M=0</span><br><span class="line">	2. 找A=0, M=1，边找边将A置0</span><br><span class="line">	3. 重复第一步</span><br></pre></td></tr></table></figure>
<h4 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a>抖动</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 定义：对某一页面频繁调度</span><br><span class="line">2. 抖动发生根本原因：系统中运行的今晨管太多，分配给每个进程的物理块少，不能满足正常运行的需求</span><br><span class="line">3. 解决（工作集）：</span><br><span class="line">	1. 工作集窗口 &gt;= 工作集大小（取集合计算的性质）</span><br><span class="line">	2. 驻留集：工作集中的页面调入到内存中</span><br></pre></td></tr></table></figure>
<h2 id="Chapter-4-设备管理"><a href="#Chapter-4-设备管理" class="headerlink" title="Chapter 4 设备管理"></a><strong>Chapter 4 设备管理</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. I/O系统的：基本概念、I/O控制方式（程序I/0、中断、DMA、通道）、相关数据结构、缓冲管理（单缓冲、双缓冲、循环缓冲、缓冲池）</span><br><span class="line">2. 磁盘管理与磁盘调度算法：SSTF算法，SCAN算法，CSCAN算法，N-STEP-SCAN算法，FSCAN算法</span><br><span class="line">3. 设备分配、设备处理、虚拟设备，Spooling系统</span><br></pre></td></tr></table></figure>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>I/O设备分类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">按信息交换的单位分类：</span><br><span class="line">    1. 块设备（磁盘、硬盘）：有结构设备，速率高、可寻址</span><br><span class="line">    2. 字符设备（打印机、终端）：无结构类型、速率低、不可寻址</span><br><span class="line">按传输速率分类：</span><br><span class="line">	1. 低速设备：键盘、鼠标</span><br><span class="line">	2，中速设备：打印机</span><br><span class="line">	3. 高速设备：磁盘、光盘</span><br></pre></td></tr></table></figure>
<p>I/O设备接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CPU与控制器接口 &lt;-&gt; I/O逻辑 &lt;-&gt; 控制器与设备接口：</span><br><span class="line">    1. CPU与设备控制器的接口</span><br><span class="line">        1. 数据线</span><br><span class="line">        2. 地址线</span><br><span class="line">        3. 控制线</span><br><span class="line">    2. I/O逻辑</span><br><span class="line">        1. 用于实现对设备的控制</span><br><span class="line">        2. 通过控制线与CPU交互，将收到的控制命令进行译码</span><br><span class="line">    3. 设备控制器与设备的接口</span><br><span class="line">        1. 一个设备控制器可以连接多个设备</span><br><span class="line">        2. 每个接口中都存在数据、地址、控制三种类型的信号</span><br></pre></td></tr></table></figure>
<p>设备控制器的功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 接收和识别CPU发来的命令（读、写、查找）</span><br><span class="line">2. 数据交换，包括设备控制器之间的数据传输，以及控制器和主存之间的数据传输</span><br><span class="line">3. 表示和报告设备的状态</span><br><span class="line">4. 地址识别</span><br><span class="line">5. 数据缓冲</span><br><span class="line">6. 差错控制</span><br></pre></td></tr></table></figure>
<p>I/O软件层次结构：</p>
<table>
<thead>
<tr>
<th style="text-align:center">用户层I/O软件（read、write）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">设备独立性软件（统筹管理所有I/O设备（调度与保护），提供系统调用接口、逻辑设备表存于此处）</td>
</tr>
<tr>
<td style="text-align:center">设备驱动程序（对上对硬件传入的raw数据进行解码，对下命令翻译成对应的指令（机器码））</td>
</tr>
<tr>
<td style="text-align:center">中断处理程序（对上传递硬件状态，对下直接操作硬件）</td>
</tr>
<tr>
<td style="text-align:center">硬件</td>
</tr>
</tbody>
</table>
<h3 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I/O控制方式"></a>I/O控制方式</h3><h4 id="程序I-0（程序直接控制）"><a href="#程序I-0（程序直接控制）" class="headerlink" title="程序I/0（程序直接控制）"></a>程序I/0（程序直接控制）</h4><p>对外设进行循环检查</p>
<h4 id="中断（中断驱动）"><a href="#中断（中断驱动）" class="headerlink" title="中断（中断驱动）"></a>中断（中断驱动）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 允许I/O设备主动打断CPU的运行并请求服务</span><br><span class="line">2. 一次读取两次中断</span><br><span class="line">	1. 发出I/O指令后，需要中断阻塞提出I/O请求的进程</span><br><span class="line">	2. 当传输完成时，需要中断对CPU发出信号</span><br></pre></td></tr></table></figure>
<h4 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h4><p>特点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 基本单位是数据块</span><br><span class="line">2. 内存与外存的数据交换不经过CPU</span><br><span class="line">3. 仅在数据传送的开始和结束时才需要CPU干预，传输中由DMA控制器控制：</span><br><span class="line">	1. 命令/状态寄存器(MA)</span><br><span class="line">	2. 内存地址寄存器(MAR)</span><br><span class="line">	3. 数据寄存器(DR)</span><br><span class="line">	4. 数据计数器(DC)，计数的单位是数据总线的位宽，即一个字</span><br></pre></td></tr></table></figure>
<p>工作过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. CPU -&gt; DMA控制器，设置MAR, DC初值</span><br><span class="line">2. DMA控制器与存储器直接交互（请求总线 -&gt; 进行传输）</span><br><span class="line">3. 传送完成发出中断信号给CPU</span><br></pre></td></tr></table></figure>
<h4 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h4><p>I/O通道是<strong>专门负责输入/输出的处理机</strong>，能进一步减少CPU的干预，实现CPU、通道、I/O设备三者并行操作</p>
<p>I/O通道与一般处理机的区别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通道执行的类型单一，没有自己的内存，通道所执行的通道程序是放在主机的内存中，通道与CPU共享内存</span><br></pre></td></tr></table></figure>
<p>I/O通道与DMA方式的区别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. DMA方式需要CPU来控制传输的数据块大小、传输的内存位置，而通道方式中这些信息是由通道控制的</span><br><span class="line">2. 每个DMA控制器对应一台设备与内存传递数据，而一个通道可以控制多台设备与内存的数据交换</span><br></pre></td></tr></table></figure>
<h3 id="相关数据结构"><a href="#相关数据结构" class="headerlink" title="相关数据结构"></a>相关数据结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 系统设备表(SDT) system device table</span><br><span class="line">2. 设备控制表(DCT) device control table</span><br><span class="line">3. 控制器控制表(COCT) controller control table </span><br><span class="line">4. 通道控制表(CHCT) channel control table</span><br><span class="line">5. 逻辑设备表(LUT) logic unit table</span><br></pre></td></tr></table></figure>
<h4 id="逻辑设备表"><a href="#逻辑设备表" class="headerlink" title="逻辑设备表"></a>逻辑设备表</h4><table>
<thead>
<tr>
<th style="text-align:center">逻辑设备名</th>
<th style="text-align:center">物理设备名</th>
<th style="text-align:center">驱动程序入口地址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">/dev/tty</td>
<td style="text-align:center">3</td>
<td style="text-align:center">1024</td>
</tr>
<tr>
<td style="text-align:center">/dev/printer</td>
<td style="text-align:center">5</td>
<td style="text-align:center">2046</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
</tbody>
</table>
<p>配置系统设备表的多用户系统中的逻辑设备表格式：</p>
<table>
<thead>
<tr>
<th style="text-align:center">逻辑设备名</th>
<th style="text-align:center">系统设备表</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">/dev/tty</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">/dev/printer</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
</tbody>
</table>
<h3 id="缓冲管理"><a href="#缓冲管理" class="headerlink" title="缓冲管理"></a>缓冲管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C, 处理时间</span><br><span class="line">T, 缓冲区（内存）传入工作区（CPU）时间</span><br><span class="line">M, I/O设备传入缓冲区时间</span><br></pre></td></tr></table></figure>
<p>引入缓冲区的目的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 缓解CPU和I/O设备速率不匹配</span><br><span class="line">2. 减少对CPU的终端频率，放宽对CPU中断响应时间的限制</span><br><span class="line">3. 解决基本数据单元大小不匹配的问题（字节、比特）</span><br><span class="line">4. 提高CPU和I/O设备之间的并行性</span><br></pre></td></tr></table></figure>
<p>实现方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 硬件缓冲器</span><br><span class="line">2. 缓冲区（使用部分内存）</span><br></pre></td></tr></table></figure>
<h4 id="单缓冲"><a href="#单缓冲" class="headerlink" title="单缓冲"></a>单缓冲</h4><p>$$<br>平均用时T = max(C,T) + M<br>$$</p>
<h4 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h4><p>双缓冲提高了处理机和输入设备的并行程度<br>$$<br>平均用时T = max(C+M, T)<br>$$</p>
<h4 id="循环缓冲"><a href="#循环缓冲" class="headerlink" title="循环缓冲"></a>循环缓冲</h4><p>循环队列</p>
<h4 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">三个队列：</span><br><span class="line">	1. 空缓冲队列</span><br><span class="line">	2. 装满输入数据的缓冲队列</span><br><span class="line">	3. 装满输出数据的缓冲队列</span><br><span class="line">四个缓冲区：</span><br><span class="line">	1. 收容输入数据</span><br><span class="line">	2. 提取输入数据</span><br><span class="line">	3. 收容输出数据</span><br><span class="line">	4. 提取数据数据</span><br></pre></td></tr></table></figure>
<h3 id="磁盘管理与磁盘调度算法"><a href="#磁盘管理与磁盘调度算法" class="headerlink" title="磁盘管理与磁盘调度算法"></a>磁盘管理与磁盘调度算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. SSTF算法（最短寻找时间优先）</span><br><span class="line">2. SCAN算法（电梯）</span><br><span class="line">3. CSCAN算法（循环扫描）</span><br><span class="line">4. N-STEP-SCAN算法：</span><br><span class="line">	把磁盘请求队列分为若干个长度为N的子队列，按照FCFS顺序访问这些子队列，但是每个子队列里面都是按照SCAN算法处理。</span><br><span class="line">5. FSCAN算法：</span><br><span class="line">	将磁盘请求队列分为两个子队列，一个是当前所有请求队列，按照SCAN算法处理，另一个是扫描期间新出现的请求汇合成另一个子队列。</span><br></pre></td></tr></table></figure>
<p>寻找时间 = 跨越n条磁道的时间 + 启动磁臂的时间：<br>$$<br>T_s = m * n + s,<br>$$<br>旋转延迟时间：磁头定位到某一磁道的扇区所需要的时间<br>$$<br>T_r = \frac{1}{2r}，r为磁盘的旋转速度<br>$$<br>传输时间：从磁盘读出/写入数据所经历的时间，取决于每次所读/写的字节数b和磁盘的旋转速度<br>$$<br>T_t = \frac{b}{rN}，r为磁盘转速，N为一个磁道上的字节数， rN为磁盘读取速率<br>$$<br>总平均存取时间：<br>$$<br>T_a = T_s + T_r + T_t = T_s + \frac{1}{2r} + \frac{b}{rN}<br>$$</p>
<table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>SSTF</td>
<td>性能比FCFS好</td>
<td>不能保证平均寻道时间最短，可能出现“饥饿”现象</td>
</tr>
<tr>
<td>SCAN</td>
<td>寻道性能较好，避免“饥饿”现象</td>
<td>不利于远离磁头一端的访问请求</td>
</tr>
<tr>
<td>C-SCAN</td>
<td>消除了对两端磁道请求的不公平</td>
<td></td>
</tr>
<tr>
<td>N-STEP-SCAN</td>
<td></td>
<td></td>
</tr>
<tr>
<td>FSCAN</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h3><h4 id="设备分配"><a href="#设备分配" class="headerlink" title="设备分配"></a>设备分配</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 独占式设备</span><br><span class="line">2. 分时式共享使用设备</span><br><span class="line">3. 以SPOOLing方式使用外部设备：实现了虚拟设备功能，实质上实现了对设备的I/O操作的批处理</span><br></pre></td></tr></table></figure>
<p>数据结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 系统设备表(SDT)</span><br><span class="line">2. 设备控制表(DCT)</span><br><span class="line">3. 控制器控制表(COCT)controller control table </span><br><span class="line">4. 通道控制表(CHCT) channel control table</span><br><span class="line"></span><br><span class="line">   分配设备 -&gt; 分配控制器 -&gt; 分配通道</span><br><span class="line">SDT -&gt; DCT -&gt; COCT -&gt; CHCT</span><br></pre></td></tr></table></figure>
<p>设备分配中应该考虑的问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1. 设备固有属性</span><br><span class="line">	1. 独占性：对于独占设备，应采用独享分配策略（静态分配），即将一个设备分配给某进程后，便由该进程独占，直至该进程完成或释放该设备，然后，系统才能再将该设备分配给其他进程使用。这种分配策略的缺点是，设备得不到充分利用，而且还可能引起死锁。</span><br><span class="line">	2. 共享性：对于共享设备，可同时分配给多个进程使用（动态分配），此时须注意对这些进程访问该设备的先后次序进行合理的调度。</span><br><span class="line">	3. 可虚拟设备：由于可虚拟设备是指一台物理设备在采用虚拟技术后，可变成多台逻辑上的所谓虚拟设备，因而说，一台可虚拟设备是可共享的设备，可以将它同时分配给多个进程使用，并对这些访问该(物理)设备的先后次序进行控制。</span><br><span class="line"></span><br><span class="line">2. 设备分配算法</span><br><span class="line">	1. 先请求先分配</span><br><span class="line">	2. 优先级</span><br><span class="line">3. 设备分配的安全性：</span><br><span class="line">    1. 安全分配方式：</span><br><span class="line">        1. 进程发出I/O请求后就被阻塞，I/O完成时被唤醒</span><br><span class="line">        2. CPU和I/O串行工作</span><br><span class="line">        3. 进程被阻塞无法再请求资源，破坏了了造成死锁的四个必要条件之一的“请求和保持”条件</span><br><span class="line">    2. 不安全分配方式</span><br><span class="line">        1. 进程发出I/O请求后继续运行，仅当I/O设备被占用时阻塞</span><br><span class="line">        2. 一个进程可以同时操作多个设备</span><br><span class="line">        3. 进程在运行时可能提出新的请求，可能造成死锁</span><br></pre></td></tr></table></figure>
<p>设备分配程序的改进 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 仔细研究上述基本的设备分配程序后可以发现: </span><br><span class="line">	1. 进程是以物理设备名来提出I/O请求的</span><br><span class="line">	2. 采用的是单通路的I/O系统结构，容易产生“瓶颈”现象</span><br><span class="line">	</span><br><span class="line">2. 为此，应从以下两方面对基本的设备分配程序加以改进，以使独占设备的分配程序具有更强的灵活性，并提高分配的成功率。 </span><br><span class="line">	1. 增加设备的独立性为了获得设备的独立性，进程应使用逻辑设备名请求I/O。这样，系统首先从SDT中找出第一个该类设备的DCT。若该设备忙，又查找第二个该类设备的DCT，仅当所有该类设备都忙时，才把进程挂在该类设备的等待队列上；而只要有一个该类设备可用，系统便进一步计算分配该设备的安全性。</span><br><span class="line">	2. 考虑多通路情况为了防止在I/O系统中出现“瓶颈”现象，通常都采用多通路的I/O系统结构。此时对控制器和通道的分配同样要经过几次反复，即若设备（控制器）所连接的第一个控制器（通道）忙时，应查看其所连接的第二个控制器（通道），仅当所有的控制器（通道）都忙时，此次的控制器（通道）分配才算失败，才把进程挂在控制器(通道)的等待队列上。而只要有一个控制器（通道）可用，系统便可将它分配给进程。</span><br></pre></td></tr></table></figure>
<h4 id="设备处理（设备驱动程序-CPU发起的中断处理程序）"><a href="#设备处理（设备驱动程序-CPU发起的中断处理程序）" class="headerlink" title="设备处理（设备驱动程序+CPU发起的中断处理程序）"></a>设备处理（设备驱动程序+CPU发起的中断处理程序）</h4><p><strong>此处要区别中断处理程序是由设备无关软件发起，还是由驱动程序发起。中断仅仅是进程调度的信号，前者中断处理程序由操作系统负责；后者中断处理程序由设备生产厂家负责，由设备的类型、厂家、型号不同而不同。</strong></p>
<p>当一个进程请求I/O操作时，该进程将被挂起，直到I/O设备完成I/O操作后，设备控制器便向CPU发送一中断请求，<strong>CPU</strong>响应后便转向中断处理程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 唤醒被阻塞的驱动进程</span><br><span class="line">2. 保护被中断进程的CPU环境</span><br><span class="line">3. 分析中断原因，转入相应的设备处理程序（设备驱动）</span><br><span class="line">4. 中断处理，该中断处理过程因设备的不同而不同</span><br><span class="line">5. 恢复被中断进程的现场</span><br></pre></td></tr></table></figure>
<p>设备驱动程序的处理过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 将抽象要求转换为具体要求（此处开始引入设备特有的指令、机器码）</span><br><span class="line">2. 检查 I/O 请求的合法性</span><br><span class="line">3. 读出和检查设备的状态</span><br><span class="line">4. 传送必要的参数</span><br><span class="line">5. 工作方式的设置</span><br><span class="line">6. 启动 I/O 设备</span><br></pre></td></tr></table></figure>
<h4 id="虚拟设备"><a href="#虚拟设备" class="headerlink" title="虚拟设备"></a>虚拟设备</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 提高设备分配的灵活性和设备的利用率</span><br><span class="line">2. 方便实现I/O重定向</span><br><span class="line">3. 引入了设备独立性</span><br></pre></td></tr></table></figure>
<p>逻辑设备表(Logical Unit Table, LUT)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 进程利用逻辑设备名请求服务</span><br><span class="line">2. 系统为他分配一台相应的物理设备，并在LUT中建立一个表目</span><br><span class="line">3. 之后进程利用逻辑设备名请求服务时，系统通过查找LUT来寻找对应的物理设备和驱动程序</span><br></pre></td></tr></table></figure>
<h4 id="Spooling系统"><a href="#Spooling系统" class="headerlink" title="Spooling系统"></a>Spooling系统</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. 输入井和输出井</span><br><span class="line">	1. 磁盘中</span><br><span class="line">	2. 输入井用于收容I/O设备输入的数据</span><br><span class="line">	3. 输出井用于收容用户程序输出的数据</span><br><span class="line">2. 输入缓冲区和输出缓冲区</span><br><span class="line">	1. 内存中</span><br><span class="line">	2. 输入缓冲区用于暂存输入设备送入的数据</span><br><span class="line">	3. 输出缓冲区用于暂存从输出井送来的数据</span><br><span class="line">3. 输入/输出进程</span><br><span class="line"> 	1. 用于模拟脱机输入、输出时的外围控制机</span><br><span class="line"> 	2. 输入进程：输入设备 -&gt; 输入缓冲区 -&gt; 输入井 -&gt; 用户进程空间（内存）</span><br><span class="line"> 	3. 输出进程：用户进程空间 -&gt; 输出井 -&gt; 输出缓冲区 -&gt; 输出设备（打印机）</span><br></pre></td></tr></table></figure>
<h2 id="Chapter-5-文件系统"><a href="#Chapter-5-文件系统" class="headerlink" title="Chapter 5 文件系统"></a><strong>Chapter 5 文件系统</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 基本概念：文件和文件系统、目录、文件结构的物理结构和逻辑结构（顺序文件、索引顺序文件、索引文件、HASH 文件）、文件共享（基于索引节点、基于符号链接实现文件共享）</span><br><span class="line">2. 外存分配方法：连续分配、链接分配、索引分配</span><br><span class="line">3. 目录管理：单级目录、二级目录、多级目录</span><br><span class="line">4. 文件存储空间的管理技术：位示图、空闲链表、索引</span><br></pre></td></tr></table></figure>
<h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="文件和文件系统"><a href="#文件和文件系统" class="headerlink" title="文件和文件系统"></a>文件和文件系统</h4><p>文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 以硬盘为载体的存储字啊计算机上的信息集合</span><br><span class="line">2. 用户在输入、输出中以文件为基本单位</span><br></pre></td></tr></table></figure>
<p>文件的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 名称</span><br><span class="line">2. 类型</span><br><span class="line">3. 创建者</span><br><span class="line">4. 所有者</span><br><span class="line">5. 位置</span><br><span class="line">6. 大小</span><br><span class="line">7. 保护</span><br><span class="line">8. 创建时间</span><br></pre></td></tr></table></figure>
<p>文件控制块(FCB) = 文件目录项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 基本信息：文件名、物理位置、逻辑结构、物理结构</span><br><span class="line">2. 存取控制信息：ugo的存储权现</span><br><span class="line">3. 使用信息：建立时间、上次修改时间</span><br></pre></td></tr></table></figure>
<p>索引节点(inode)：在检索目录时，文件的其他描述信息不会用到，也不需要调入内存。因此，有的系统(UNIX)便采用了文件名和文件描述信息分开的方法，使文件描述信息单独形成一个称为索引结点的数据结构<br>$$<br>FCB = 文件目录项<br>\begin{cases}<br>文件名\<br>i结点（文件描述信息）<br>\end{cases}<br>$$<br>磁盘索引结点：存放在磁盘上的索引结点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 文件主标识符</span><br><span class="line">2. 文件类型：普通文件、目录文件、特殊文件</span><br><span class="line">3. 文件存取权现</span><br><span class="line">4. 文件物理地址</span><br><span class="line">5. 文件长度</span><br><span class="line">6. 文件链接计数</span><br><span class="line">7. 文件存取时间：最近存取、最近修改的时间</span><br></pre></td></tr></table></figure>
<p>内存索引结点：文件被打开时，从硬盘索引结点中复制到内存，增加了以下内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 索引结点编号</span><br><span class="line">2. 状态：有无被上锁</span><br><span class="line">3. 访问计数：有多少进程正在访问</span><br><span class="line">4. 逻辑设备号：文件所属系统的逻辑设备号</span><br><span class="line">5. 链接指针：指向空闲链表、散列队列的指针</span><br></pre></td></tr></table></figure>
<p>文件操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 创建文件</span><br><span class="line">2. 写文件</span><br><span class="line">3. 读文件</span><br><span class="line">4. 重新定位文件：将文件位置指针重新定位到新值</span><br><span class="line">5. 删除文件：释放存储空间，删除目录条目</span><br><span class="line">6. 截断文件：保持文件属性不变，删除文件内容</span><br></pre></td></tr></table></figure>
<p>打开文件表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. 调用open()后，文件属性从硬盘复制到内存的打开文件表中，返回用户文件属性在打开文件表中的编号</span><br><span class="line">2. 内核为每个进程维护一个打开文件表（返回给用户的索引），索引指向的是系统范围的打开文件表，真正保存了文件属性</span><br><span class="line">3. 其他进程调用open()打开此文件，仅在其进程的打开文件表增加一项指向系统范围打开文件表的索引</span><br><span class="line">4. 文件名不必是打开文件表的一部分，一旦完成FCB在磁盘上的定位，系统就不再使用文件名，只要文件未关闭，系统就使用打开文件表来进行（允许多个进程打开同个文件的系统中应该还是要保留文件名，用于在打开文件表中检索）</span><br><span class="line">5. 对于访问打开文件表的索引，UNIX称之为文件描述符，Windows称之为文件句柄</span><br><span class="line">6. 每个打开文件表都关联如下信息：</span><br><span class="line">	1. 文件指针</span><br><span class="line">	2. 文件打开计数</span><br><span class="line">	3. 文件磁盘位置</span><br><span class="line">	4. 访问权现</span><br></pre></td></tr></table></figure>
<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><h4 id="文件结构的物理结构和逻辑结构（顺序文件、索引顺序文件、索引文件、HASH-文件）"><a href="#文件结构的物理结构和逻辑结构（顺序文件、索引顺序文件、索引文件、HASH-文件）" class="headerlink" title="文件结构的物理结构和逻辑结构（顺序文件、索引顺序文件、索引文件、HASH 文件）"></a>文件结构的物理结构和逻辑结构（顺序文件、索引顺序文件、索引文件、HASH 文件）</h4><h4 id="文件共享（基于索引节点、基于符号链接实现文件共享）"><a href="#文件共享（基于索引节点、基于符号链接实现文件共享）" class="headerlink" title="文件共享（基于索引节点、基于符号链接实现文件共享）"></a>文件共享（基于索引节点、基于符号链接实现文件共享）</h4><p>符号链接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 建立符号链接时，引用计数值直接复制</span><br><span class="line">2. 删除操作对于符号链接是不可见的</span><br><span class="line">3. 访问时发现文件不存在，则删除此符号链接</span><br></pre></td></tr></table></figure>
<h3 id="外存分配方法："><a href="#外存分配方法：" class="headerlink" title="外存分配方法："></a>外存分配方法：</h3><h4 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">优点：</span><br><span class="line">	1. 顺序访问容易</span><br><span class="line">	2. 顺序访问速度快</span><br><span class="line">缺点：</span><br><span class="line">	1. 必须要有连续的存储空间</span><br><span class="line">	2. 必须事先知道文件的长度</span><br></pre></td></tr></table></figure>
<h4 id="链接分配"><a href="#链接分配" class="headerlink" title="链接分配"></a>链接分配</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 显式链接：</span><br><span class="line">	1. 在采用隐式链接分配方式时，在文件目录的每个目录项中，都须含有指向链接文件第一个盘块和最后一个盘块的指针。指向下一个盘块的指针存放在每个盘块里</span><br><span class="line">	2. 主要问题：只适合顺序访问</span><br><span class="line">2. 隐式链接：文件分配表(FAT)：</span><br><span class="line">	1. 把用于链接文件各物理块的指针，显式地存放在内存的一张链接表中，该表在整个磁盘仅设置一张</span><br><span class="line">	2. 由于查找记录的过程是在内存中进行的，因而不仅显著地提高了检索速度，而且大大减少了访问磁盘的次数</span><br></pre></td></tr></table></figure>
<h4 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 单级索引分配：直接访问</span><br><span class="line">2. 多级索引分配</span><br><span class="line">3. 混合索引分配;</span><br><span class="line">	1. 直接地址</span><br><span class="line">	2. 一次间接地址</span><br><span class="line">	3. 多次间接地址</span><br></pre></td></tr></table></figure>
<h3 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h3><h4 id="单级目录"><a href="#单级目录" class="headerlink" title="单级目录"></a>单级目录</h4><table>
<thead>
<tr>
<th style="text-align:center">文件名</th>
<th style="text-align:center">物理地址</th>
<th style="text-align:center">文件说明</th>
<th style="text-align:center">状态位</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">文件名1</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">文件名2</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">优点：</span><br><span class="line">	1. 简单</span><br><span class="line">	2. 能实现按名存取</span><br><span class="line">缺点：</span><br><span class="line">	1. 查找速度慢</span><br><span class="line">	2. 不允许重名</span><br><span class="line">	3. 不便实现文件共享</span><br></pre></td></tr></table></figure>
<h4 id="二级目录"><a href="#二级目录" class="headerlink" title="二级目录"></a>二级目录</h4><p>为了克服单级目录所存在的缺点，可以为每一个用户建立一个单独的用户文件目录UFD(User File Directory)。</p>
<table>
<thead>
<tr>
<th style="text-align:center">用户名</th>
<th style="text-align:center">指向子目录指针</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Alice</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Bob</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">…</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">优点：</span><br><span class="line">	1. 提高检索目录的速度</span><br><span class="line">	2. 在不同的目录中允许重名文件存在</span><br><span class="line">	3. 不同的用户可以使用不同的文件名访问系统中的同一个文件</span><br><span class="line">缺点：在需要多用户合作时，不同的用户可以使用不同的文件名访问系统中的同一个文件，不利于共享文件</span><br></pre></td></tr></table></figure>
<h4 id="多级目录"><a href="#多级目录" class="headerlink" title="多级目录"></a>多级目录</h4><p><img src="/2023/02/15/caozuoxitong/duojimulujiegou.png" alt></p>
<h3 id="文件存储空间的管理技术"><a href="#文件存储空间的管理技术" class="headerlink" title="文件存储空间的管理技术"></a>文件存储空间的管理技术</h3><h4 id="位示图"><a href="#位示图" class="headerlink" title="位示图"></a>位示图</h4><p><img src="/2023/02/15/caozuoxitong/weishitu.png" alt></p>
<h4 id="空闲链表"><a href="#空闲链表" class="headerlink" title="空闲链表"></a>空闲链表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 空闲表</span><br><span class="line">2. 空闲链表</span><br></pre></td></tr></table></figure>
<h4 id="索引（成组链接法）"><a href="#索引（成组链接法）" class="headerlink" title="索引（成组链接法）"></a>索引（成组链接法）</h4><p><img src="/2023/02/15/caozuoxitong/chengzulianjiefa.png" alt></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/仅供学习参考/" rel="tag"># 仅供学习参考</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2022/11/06/restart/" rel="next" title="Restart">
                <i class="fa fa-chevron-left"></i> Restart
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2024/08/08/update/" rel="prev" title="小小的更新">
                小小的更新 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/1.JPG" alt="Grilled Fish">
            
              <p class="site-author-name" itemprop="name">Grilled Fish</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Chapter-1-操作系统概观"><span class="nav-number">1.</span> <span class="nav-text">Chapter 1 操作系统概观</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#批处理与多道程序设计"><span class="nav-number">1.1.</span> <span class="nav-text">批处理与多道程序设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#单道批处理"><span class="nav-number">1.1.1.</span> <span class="nav-text">单道批处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多道批处理"><span class="nav-number">1.1.2.</span> <span class="nav-text">多道批处理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分时系统与实时系统"><span class="nav-number">1.2.</span> <span class="nav-text">分时系统与实时系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#分时OS"><span class="nav-number">1.2.1.</span> <span class="nav-text">分时OS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实时OS"><span class="nav-number">1.2.2.</span> <span class="nav-text">实时OS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分时OS和实时OS的比较"><span class="nav-number">1.2.3.</span> <span class="nav-text">分时OS和实时OS的比较</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作系统的类型和基本特征"><span class="nav-number">1.3.</span> <span class="nav-text">操作系统的类型和基本特征</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#操作系统的目标和功能"><span class="nav-number">1.3.1.</span> <span class="nav-text">操作系统的目标和功能</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并发与并行的概念"><span class="nav-number">1.4.</span> <span class="nav-text">并发与并行的概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#并发"><span class="nav-number">1.4.1.</span> <span class="nav-text">并发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#并行"><span class="nav-number">1.4.2.</span> <span class="nav-text">并行</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#计算机层次结构与功能模块"><span class="nav-number">1.5.</span> <span class="nav-text">计算机层次结构与功能模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#程序的顺序执行与并发执行"><span class="nav-number">1.6.</span> <span class="nav-text">程序的顺序执行与并发执行</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Chapter-2-进程管理"><span class="nav-number">2.</span> <span class="nav-text">Chapter 2 进程管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程"><span class="nav-number">2.1.</span> <span class="nav-text">进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#进程控制块"><span class="nav-number">2.1.1.</span> <span class="nav-text">进程控制块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程的几种基本状态与状态转换"><span class="nav-number">2.1.2.</span> <span class="nav-text">进程的几种基本状态与状态转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程的同步与互斥"><span class="nav-number">2.2.</span> <span class="nav-text">进程的同步与互斥</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#临界资源"><span class="nav-number">2.2.1.</span> <span class="nav-text">临界资源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#临界区"><span class="nav-number">2.2.2.</span> <span class="nav-text">临界区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程同步与互斥问题"><span class="nav-number">2.2.3.</span> <span class="nav-text">进程同步与互斥问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#信号量机制以及P、V操作"><span class="nav-number">2.2.4.</span> <span class="nav-text">信号量机制以及P、V操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#管程机制-monitor"><span class="nav-number">2.2.5.</span> <span class="nav-text">管程机制(monitor)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程间通信"><span class="nav-number">2.3.</span> <span class="nav-text">进程间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#进程通信的类型-直接通信和间接通信方式"><span class="nav-number">2.3.1.</span> <span class="nav-text">进程通信的类型(直接通信和间接通信方式)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#消息传递系统中的几个问题"><span class="nav-number">2.3.2.</span> <span class="nav-text">消息传递系统中的几个问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#消息缓冲队列通信机制"><span class="nav-number">2.3.3.</span> <span class="nav-text">消息缓冲队列通信机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程与进程的调度"><span class="nav-number">2.4.</span> <span class="nav-text">线程与进程的调度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#线程与进程的基本概念"><span class="nav-number">2.4.1.</span> <span class="nav-text">线程与进程的基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#调度的类型"><span class="nav-number">2.4.2.</span> <span class="nav-text">调度的类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#调度队列模型"><span class="nav-number">2.4.3.</span> <span class="nav-text">调度队列模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#调度方式"><span class="nav-number">2.4.4.</span> <span class="nav-text">调度方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#调度的目标"><span class="nav-number">2.4.5.</span> <span class="nav-text">调度的目标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程调度算法"><span class="nav-number">2.4.6.</span> <span class="nav-text">进程调度算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁"><span class="nav-number">2.5.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁的基本概念"><span class="nav-number">2.5.1.</span> <span class="nav-text">死锁的基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁预防"><span class="nav-number">2.5.2.</span> <span class="nav-text">死锁预防</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁避免与处理死锁的基本方法"><span class="nav-number">2.5.3.</span> <span class="nav-text">死锁避免与处理死锁的基本方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁定理（死锁检测）"><span class="nav-number">2.5.4.</span> <span class="nav-text">死锁定理（死锁检测）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Chapter-3-内存管理"><span class="nav-number">3.</span> <span class="nav-text">Chapter 3 内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内存管理的需求"><span class="nav-number">3.1.</span> <span class="nav-text">内存管理的需求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#程序的装入和链接"><span class="nav-number">3.2.</span> <span class="nav-text">程序的装入和链接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#连续分配：分区存储管理"><span class="nav-number">3.3.</span> <span class="nav-text">连续分配：分区存储管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#分区方式"><span class="nav-number">3.3.1.</span> <span class="nav-text">分区方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可变式分区：分区分配算法"><span class="nav-number">3.3.2.</span> <span class="nav-text">可变式分区：分区分配算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#伙伴系统：固定分区和动态分区的折中"><span class="nav-number">3.3.3.</span> <span class="nav-text">伙伴系统：固定分区和动态分区的折中</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#离散分配：基本段式管理与页式管理"><span class="nav-number">3.4.</span> <span class="nav-text">离散分配：基本段式管理与页式管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#快表TLB"><span class="nav-number">3.4.1.</span> <span class="nav-text">快表TLB</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#页式管理机制"><span class="nav-number">3.4.2.</span> <span class="nav-text">页式管理机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#段式管理"><span class="nav-number">3.4.3.</span> <span class="nav-text">段式管理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟内存："><span class="nav-number">3.5.</span> <span class="nav-text">虚拟内存：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#局部性原理"><span class="nav-number">3.5.1.</span> <span class="nav-text">局部性原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚拟内存概念"><span class="nav-number">3.5.2.</span> <span class="nav-text">虚拟内存概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#请求分段与请求分页"><span class="nav-number">3.5.3.</span> <span class="nav-text">请求分段与请求分页</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#请求分页"><span class="nav-number">3.5.3.1.</span> <span class="nav-text">请求分页</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#段页式管理"><span class="nav-number">3.5.4.</span> <span class="nav-text">段页式管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#页面置换算法"><span class="nav-number">3.5.5.</span> <span class="nav-text">页面置换算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#抖动"><span class="nav-number">3.5.6.</span> <span class="nav-text">抖动</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Chapter-4-设备管理"><span class="nav-number">4.</span> <span class="nav-text">Chapter 4 设备管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本概念"><span class="nav-number">4.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O控制方式"><span class="nav-number">4.2.</span> <span class="nav-text">I/O控制方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#程序I-0（程序直接控制）"><span class="nav-number">4.2.1.</span> <span class="nav-text">程序I/0（程序直接控制）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#中断（中断驱动）"><span class="nav-number">4.2.2.</span> <span class="nav-text">中断（中断驱动）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DMA"><span class="nav-number">4.2.3.</span> <span class="nav-text">DMA</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通道"><span class="nav-number">4.2.4.</span> <span class="nav-text">通道</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#相关数据结构"><span class="nav-number">4.3.</span> <span class="nav-text">相关数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#逻辑设备表"><span class="nav-number">4.3.1.</span> <span class="nav-text">逻辑设备表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓冲管理"><span class="nav-number">4.4.</span> <span class="nav-text">缓冲管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#单缓冲"><span class="nav-number">4.4.1.</span> <span class="nav-text">单缓冲</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#双缓冲"><span class="nav-number">4.4.2.</span> <span class="nav-text">双缓冲</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#循环缓冲"><span class="nav-number">4.4.3.</span> <span class="nav-text">循环缓冲</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缓冲池"><span class="nav-number">4.4.4.</span> <span class="nav-text">缓冲池</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#磁盘管理与磁盘调度算法"><span class="nav-number">4.5.</span> <span class="nav-text">磁盘管理与磁盘调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设备管理"><span class="nav-number">4.6.</span> <span class="nav-text">设备管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#设备分配"><span class="nav-number">4.6.1.</span> <span class="nav-text">设备分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#设备处理（设备驱动程序-CPU发起的中断处理程序）"><span class="nav-number">4.6.2.</span> <span class="nav-text">设备处理（设备驱动程序+CPU发起的中断处理程序）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚拟设备"><span class="nav-number">4.6.3.</span> <span class="nav-text">虚拟设备</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spooling系统"><span class="nav-number">4.6.4.</span> <span class="nav-text">Spooling系统</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Chapter-5-文件系统"><span class="nav-number">5.</span> <span class="nav-text">Chapter 5 文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本概念-1"><span class="nav-number">5.1.</span> <span class="nav-text">基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#文件和文件系统"><span class="nav-number">5.1.1.</span> <span class="nav-text">文件和文件系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#目录"><span class="nav-number">5.1.2.</span> <span class="nav-text">目录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件结构的物理结构和逻辑结构（顺序文件、索引顺序文件、索引文件、HASH-文件）"><span class="nav-number">5.1.3.</span> <span class="nav-text">文件结构的物理结构和逻辑结构（顺序文件、索引顺序文件、索引文件、HASH 文件）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件共享（基于索引节点、基于符号链接实现文件共享）"><span class="nav-number">5.1.4.</span> <span class="nav-text">文件共享（基于索引节点、基于符号链接实现文件共享）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#外存分配方法："><span class="nav-number">5.2.</span> <span class="nav-text">外存分配方法：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#连续分配"><span class="nav-number">5.2.1.</span> <span class="nav-text">连续分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#链接分配"><span class="nav-number">5.2.2.</span> <span class="nav-text">链接分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#索引分配"><span class="nav-number">5.2.3.</span> <span class="nav-text">索引分配</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#目录管理"><span class="nav-number">5.3.</span> <span class="nav-text">目录管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#单级目录"><span class="nav-number">5.3.1.</span> <span class="nav-text">单级目录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二级目录"><span class="nav-number">5.3.2.</span> <span class="nav-text">二级目录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多级目录"><span class="nav-number">5.3.3.</span> <span class="nav-text">多级目录</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件存储空间的管理技术"><span class="nav-number">5.4.</span> <span class="nav-text">文件存储空间的管理技术</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#位示图"><span class="nav-number">5.4.1.</span> <span class="nav-text">位示图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#空闲链表"><span class="nav-number">5.4.2.</span> <span class="nav-text">空闲链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#索引（成组链接法）"><span class="nav-number">5.4.3.</span> <span class="nav-text">索引（成组链接法）</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Grilled Fish</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: '1YVuvg9C7OJ2GNYW4I34oHaX-gzGzoHsz',
        appKey: 'QBVuwguq0CVGMmNY88UA0raZ',
        placeholder: '喜欢您来',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
